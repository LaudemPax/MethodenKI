\section{KI-Suchverfahren}

Es gibt zwei Klassen von Suchverfahren: \textbf{blinde Suchverfahren} und \textbf{KI-Suchverfahren}. Blinde Suchverfahren sind auf einem bestimmten Schema basiert, das unabhängig von dem jeweiligen Problem ist. Einige Beispiele hierfür sind die in den vorangegangenen Kapiteln behandelten Verfahren wie Breitensuche, Tiefensuche, Biridketionale Suche usw. 

KI-Suchverfahren hingegen nutzen problemspezifisches Vorwissen zur Eingrenzung des Suchraums. Es handelt sich um informierte heuristische Suchverfarhen.

\textbf{Blinde Suchverfahren} erfordern, dass eine Lösung durch systematische und erschöpfende Suche in einem Suchgraphen gefunden wird, was ineffizient und kein problemspezifisches Wissen nutzt.

\textbf{Informierte Suchprozesse} hingegen nutzen problemspezifische Eigenschaften, um die Effizienz der Knotenexpansion zu verbessern.

\subsection{Greedy Search}
\label{section:greedy-search}
Die Greedy-Suche ist eine modifizierte Breitensuche (siehe Abschnitt \ref{section:breitensuche}), bei der nur die Knoten mit den geringsten Kosten in die Warteschlange aufgenommen werden. 

\paragraph{Ablauf von Greedy Search}

Wenn die Kosten des aktuellen Knotens zum Zielknoten unbekannt sind, \textbf{müssen diese Kosten geschätzt werden}, und dann wird der Nachbar mit den geringsten Kosten ausgewählt. Die Funktion, die diese Kosten schätzt, wird \textbf{heuristische Funktion} genannt.

Der Unterschied zwischen Greedy Search und Uniform Cost Search (siehe Abschnitt \ref{section:uniform-cost-search}) besteht darin, dass bei der Greedy Search \textbf{die Kosten von einem Knoten zum Zielknoten} berechnet werden und nicht von einem Knoten zum anderen.

\paragraph{Eigenschaften von Greedy Search}

Greedy Search bietet tendenziell schnelle Lösungen, die oft, aber nicht immer, der optimale Weg sind. 

Greedy Search ist ähnlich wie die Tiefensuche mit Backtracking, nicht vollständig, und erfordert eine gute Heuristik für eine bessere Güte des Verfahrens.

\subsection{Der A* Algorithmus}
\label{section:a-star}
Der A*-Algorithmus ist ein neuer Ansatz, der auf Greedy Search (Abbschnitt~\ref{section:greedy-search}) und dem Dijkstra-Algorithmus~(Abbschnitt~\ref{section:dijkstra}) aufbaut. A* arbeitet basierend auf der Funktion:

\[f(n) = g(n) + h(n)\]

Wobie \(f(n)\) die geschätzten Kosten der billigsten Lösung ist, \(g(n)\) die Kosten für die Bewegung von der Ausgangszelle zur aktuellen Zelle, und \(h(n)\) die geschätzten Kosten für die Bewegung von der aktuellen Zelle zur Zielzelle. Mit der Funktion \(f(n)\) werden die Kosten berechnet, und der Rest des Algorithmus läuft wie bei einer Breitensuche ab. Um eine optimale Lösung zu erzielen, sollte die heuristische Funktion \(h(n)\) die Entfernung zum Ziel nicht überschätzen. 

Ws ist auch möglich, die Gewichtung der Komponenten der A*-Kostenfunktion zu ändern:-

\[f(n) = \alpha * g(n) +  \beta * h(n)\]

Wenn \(\beta\) viel größer als \(\alpha\) ist, dann nähert sich die Suche einer Greedy Search. Andersrum ist es ähnlich wie bei einer Bretiensuche.

\subsection{Pfadplannung in Computerspielen}

Pathing-Algorithmen werden in Spielen häufig zur Navigation von Figuren in der virtuellen Welt verwendet. In frühen 3D-Spielen wurde dies durch Wegpunkte erreicht. NPCs können sich nur durch Wegpunkte bewegen und der Pfad wird mit dem A*-Algorithmus (Abbschnitt~\ref{section:a-star}) berechnet (Abb.~\ref{fig:game-navigation-waypoitns}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/kap3/games-navigation-waypoints.png}
    \caption{Spielnavigation mit Wegpunkten}
    \label{fig:game-navigation-waypoitns}
\end{figure}

Dieser Ansatz mit Wegpunkten schränkt jedoch die Bewegung der Spielfiguren stark ein. Dieser Ansatz mit Wegpunkten schränkt jedoch die Bewegung der Spielfiguren stark ein. Ein besserer Ansatz ist die Verwendung von Polygon-Netze.

Bereiche, in denen sich die Figuren frei bewegen können, werden als Polygone dargestellt, und diese Bereiche sind durch Knoten miteinander verbunden. Bei diesem Ansatz können sich die Figuren freier bewegen, und der Ansatz kann weiterhin mit bekannten Algorithmen wie A* berechnet werden.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/kap3/waypoints vs polygon.png}
    \caption{Spielnavigation mit Polygon-Meshes vs Wegpunkte}
    \label{fig:game-navigation-navmesh}
\end{figure}